/// <reference types="node" />
export = Blob;
declare class Blob {
    static [Symbol.hasInstance](object: any): boolean;
    /**
     * The Blob() constructor returns a new Blob object. The content
     * of the blob consists of the concatenation of the values given
     * in the parameter array.
     *
     * @param {(ArrayBufferLike | ArrayBufferView | Blob | Buffer | string)[]} blobParts
     * @param {{ type?: string }} [options]
     */
    constructor(blobParts?: (ArrayBufferLike | ArrayBufferView | Blob | Buffer | string)[], options?: {
        type?: string;
    });
    /**
     * The Blob interface's size property returns the
     * size of the Blob in bytes.
     */
    get size(): number;
    /**
     * The type property of a Blob object returns the MIME type of the file.
     */
    get type(): string;
    /**
     * The text() method in the Blob interface returns a Promise
     * that resolves with a string containing the contents of
     * the blob, interpreted as UTF-8.
     *
     * @return {Promise<string>}
     */
    text(): Promise<string>;
    /**
     * The arrayBuffer() method in the Blob interface returns a
     * Promise that resolves with the contents of the blob as
     * binary data contained in an ArrayBuffer.
     *
     * @return {Promise<ArrayBuffer>}
     */
    arrayBuffer(): Promise<ArrayBuffer>;
    /**
     * The Blob interface's stream() method is difference from native
     * and uses node streams instead of whatwg streams.
     *
     * @returns {Readable} Node readable stream
     */
    stream(): import("stream").Readable;
    /**
     * The Blob interface's slice() method creates and returns a
     * new Blob object which contains data from a subset of the
     * blob on which it's called.
     *
     * @param {number} [start]
     * @param {number} [end]
     * @param {string} [type]
     */
    slice(start?: number, end?: number, type?: string): Blob;
    get [Symbol.toStringTag](): string;
}
